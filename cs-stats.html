<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CS Major - Kam3l</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        body {
            margin: 0;
            padding: 20px;
            background-color: #121212;
            font-family: Arial, sans-serif;
            color: white;
            min-height: 100vh;
            position: relative;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
        }

        .back-btn {
            color: white;
            font-size: 24px;
            text-decoration: none;
            transition: color 0.3s;
        }

        .back-btn:hover {
            color: #00ff77;
        }

        .title {
            font-size: 2.5rem;
            font-weight: bold;
            background: linear-gradient(90deg, #00ff77, #ff00e6);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-align: center;
            flex-grow: 1;
        }

        .spreadsheet-container {
            background: #1a1a1a;
            border-radius: 10px;
            padding: 0;
            box-shadow: 0 0 20px rgba(0, 255, 119, 0.1);
            overflow: hidden;
            border: 2px solid #333;
        }

        .spreadsheet {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            background: #2a2a2a;
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            font-size: 11px;
        }

        .row-header {
            background: #3a3a3a;
            border: 1px solid #555;
            text-align: center;
            font-weight: bold;
            width: 40px;
            min-width: 40px;
            padding: 4px;
            color: #ccc;
            user-select: none;
        }

        .col-header {
            background: #3a3a3a;
            border: 1px solid #555;
            text-align: center;
            font-weight: bold;
            padding: 4px 8px;
            color: #ccc;
            user-select: none;
            min-width: 80px;
        }

        .cell {
            border: 1px solid #555;
            padding: 4px 8px;
            background: #2a2a2a;
            color: white;
            min-width: 80px;
            height: 20px;
            position: relative;
            cursor: cell;
            /* Default text-align is often 'start' or 'left' based on LTR/RTL.
               Explicitly setting it might be useful if consistent alignment is always desired.
               However, for serialization, we'll check if it's explicitly set. */
        }

        .cell:hover {
            background: #3a3a3a;
        }

        .cell.selected {
            background: #4285f4 !important;
            border: 2px solid #66a3ff !important;
            color: white !important;
        }

        .cell.editing {
            padding: 0;
        }

        .cell.merged {
            /* Style for merged cells, if specific visual distinction is needed beyond colspan/rowspan effects */
            /* background: #3a4a3a !important; */ /* Example, can be removed if not desired */
            /* border: 2px solid #00ff77 !important; */
        }

        /* .cell.hidden is no longer used for rendering merged cells; colspan/rowspan handles it */

        .cell-input {
            width: 100%;
            height: 100%;
            border: none;
            padding: 4px 8px;
            font-family: inherit;
            font-size: inherit;
            background: #2a2a2a;
            color: white;
            outline: none;
            box-sizing: border-box;
        }

        .admin-btn {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: #333;
            border: 1px solid #555;
            color: #888;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            opacity: 0.3;
            transition: opacity 0.3s;
            z-index: 1000;
        }

        .admin-btn:hover {
            opacity: 0.8;
        }

        .admin-panel {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #2a2a2a;
            border: 2px solid #444;
            border-radius: 8px;
            padding: 20px;
            z-index: 1001;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.8);
            min-width: 400px;
        }

        .admin-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
        }

        .password-input {
            padding: 10px;
            background: #333;
            border: 1px solid #555;
            color: white;
            border-radius: 4px;
            margin-right: 10px;
            width: 200px;
        }

        .confirm-btn {
            background: linear-gradient(45deg, #00ff77, #ff00e6);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: bold;
        }

        .close-btn {
            background: #ff4757;
            border: none;
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            float: right;
            margin-left: 10px;
        }

        .toolbar {
            display: none;
            background: #3a3a3a;
            padding: 8px;
            border-bottom: 1px solid #555;
            gap: 10px;
            flex-wrap: wrap;
        }

        .toolbar.visible {
            display: flex;
        }

        .tool-btn {
            background: #2a2a2a;
            border: 1px solid #555;
            padding: 4px 8px;
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            color: white;
        }

        .tool-btn:hover {
            background: #4a4a4a;
        }

        .tool-btn.active {
            background: #4285f4;
            color: white;
        }

        .tool-btn.merge {
            background: #00ff77;
            color: #000;
        }

        .tool-btn.unmerge {
            background: #ff4757;
            color: white;
        }

        .tool-btn.copy { /* Renamed to "Kopiuj Dane" */
            background: #ff9500;
            color: white;
        }

        .color-picker {
            width: 30px;
            height: 25px;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 3px;
        }

        .font-size-input {
            width: 50px;
            background: #2a2a2a;
            border: 1px solid #555;
            color: white;
            padding: 4px;
            border-radius: 3px;
            text-align: center;
        }

        .range-selector {
            position: absolute;
            border: 2px dashed #4285f4;
            background: rgba(66, 133, 244, 0.1);
            pointer-events: none;
            display: none;
        }

        .status {
            position: fixed;
            bottom: 20px;
            right: 20px;
            background: #333;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            color: #ccc;
            z-index: 1000;
        }

        .status.success {
            background: #00ff77;
            color: #000;
        }

        .status.error {
            background: #ff4757;
            color: white;
        }

        .copy-textarea { /* Used for tableDataOutput */
            width: 100%;
            min-height: 200px;
            background: #333;
            border: 1px solid #555;
            color: white;
            padding: 10px;
            font-family: monospace;
            font-size: 12px;
            border-radius: 4px;
            margin: 10px 0;
            resize: vertical;
            word-break: break-all; /* Ensure long strings wrap */
        }

        @media (max-width: 768px) {
            .title {
                font-size: 2rem;
            }
            
            .spreadsheet {
                font-size: 10px;
            }
            
            .cell, .col-header {
                min-width: 60px;
            }
        }
    </style>
</head>
<body>
    <div class="admin-overlay" id="adminOverlay"></div>
    
    <div class="admin-panel" id="adminPanel">
        <button class="close-btn" onclick="closeAdminPanel()">√ó</button>
        <h3 style="color: white; margin-top: 0;">Tryb Administratora</h3>
        <div>
            <input type="password" class="password-input" id="passwordInput" placeholder="Wpisz has≈Ço...">
            <button class="confirm-btn" onclick="checkPassword()">Potwierd≈∫</button>
        </div>
        
        <div id="copySection" style="display: none; margin-top: 20px; border-top: 1px solid #555; padding-top: 20px;">
            <h4 style="color: white; margin: 0 0 10px 0;">Skopiuj dane tabeli</h4>
            <p style="color: #ccc; font-size: 12px; margin-bottom: 10px;">Skopiuj poni≈ºszy zakodowany ciƒÖg i wklej go do zmiennej <code>INITIAL_TABLE_DATA</code> w pliku HTML:</p>
            <textarea class="copy-textarea" id="tableDataOutput" readonly></textarea>
            <button class="confirm-btn" onclick="copyToClipboard()" style="width: 100%;">üìã Skopiuj dane do schowka</button>
        </div>
    </div>

    <div class="header">
        <a href="index.html" class="back-btn">
            <i class="fas fa-arrow-left"></i>
        </a>
        <h1 class="title">
            <i class="fas fa-crosshairs"></i> Austin Major 2025 Pickems
        </h1>
        <div></div> <!-- Placeholder for potential right-side header content -->
    </div>

    <div class="spreadsheet-container">
        <div class="toolbar" id="toolbar">
            <button class="tool-btn" onclick="formatBold()"><b>B</b></button>
            <button class="tool-btn" onclick="formatItalic()"><i>I</i></button>
            <button class="tool-btn" onclick="formatUnderline()"><u>U</u></button>
            <span style="margin: 0 10px; color: #666;">|</span>
            <button class="tool-btn" onclick="alignLeft()">‚¨ÖÔ∏è</button>
            <button class="tool-btn" onclick="alignCenter()">‚ÜîÔ∏è</button>
            <button class="tool-btn" onclick="alignRight()">‚û°Ô∏è</button>
            <span style="margin: 0 10px; color: #666;">|</span>
            <input type="number" class="font-size-input" id="fontSizeInput" value="11" min="8" max="24" title="Rozmiar czcionki" onchange="changeFontSize()">
            <!-- <button class="tool-btn" onclick="changeFontSize()">A</button> Removed, onchange is enough -->
            <span style="margin: 0 10px; color: #666;">|</span>
            <input type="color" class="color-picker" id="bgColorPicker" value="#2a2a2a" onchange="changeBgColor()" title="Kolor t≈Ça kafelka">
            <input type="color" class="color-picker" id="textColorPicker" value="#ffffff" onchange="changeTextColor()" title="Kolor tekstu">
            <span style="margin: 0 10px; color: #666;">|</span>
            <button class="tool-btn merge" onclick="mergeCells()">üîó Po≈ÇƒÖcz</button>
            <button class="tool-btn unmerge" onclick="unmergeCells()">üîì Roz≈ÇƒÖcz</button>
            <span style="margin: 0 10px; color: #666;">|</span>
            <button class="tool-btn" onclick="addRow()">+ Wiersz</button>
            <button class="tool-btn" onclick="addColumn()">+ Kolumna</button>
            <button class="tool-btn" onclick="deleteRow()">- Wiersz</button>
            <button class="tool-btn" onclick="deleteColumn()">- Kolumna</button>
            <span style="margin: 0 10px; color: #666;">|</span>
            <button class="tool-btn copy" onclick="updateSerializedDataOutputAndShowInPanel()">üìã Kopiuj Dane</button>
        </div>
        
        <table class="spreadsheet" id="spreadsheet">
            <thead>
                <tr>
                    <th class="row-header"></th>
                    <!-- Column headers A, B, C... will be generated by JS -->
                </tr>
            </thead>
            <tbody id="spreadsheetBody">
                <!-- Spreadsheet rows and cells will be generated by JS -->
            </tbody>
        </table>
        
        <div class="range-selector" id="rangeSelector"></div>
    </div>

    <button class="admin-btn" onclick="showAdminPanel()">‚öô</button>
    <div class="status" id="status">Gotowy</div>

    <script>
        // PLACE TO PASTE THE COPIED TABLE DATA STRING:
        const INITIAL_TABLE_DATA = ""; 

        let isAdminMode = false;
        let selectedCell = null;
        let selectedCells = [];
        let isSelecting = false;
        let startCellForSelection = null; // Renamed from startCell to avoid conflict
        
        const ADMIN_PASSWORD_HASH = "ce303098f3cd33f4489a00276812742e876087a8525fafaaa4a2e386ddc7dcf5"; // sha256("kam3l")
        
        function showStatus(message, type = 'normal') {
            const statusEl = document.getElementById('status');
            statusEl.textContent = message;
            statusEl.className = 'status'; // Reset classes
            if (type === 'success') statusEl.classList.add('success');
            if (type === 'error') statusEl.classList.add('error');
            
            setTimeout(() => {
                statusEl.textContent = 'Gotowy';
                statusEl.className = 'status';
            }, 3000);
        }
        
        function initSpreadsheet(initialDataString = INITIAL_TABLE_DATA) {
            const tbody = document.getElementById('spreadsheetBody');
            tbody.innerHTML = ''; // Clear existing content
            const headerRow = document.querySelector('#spreadsheet thead tr');
            // Clear existing column headers (except the first empty one for row numbers)
            while (headerRow.children.length > 1) {
                headerRow.removeChild(headerRow.lastChild);
            }

            let tableConfig = {
                rows: 20, // Default rows
                cols: 8,  // Default columns
                cellData: {} // Stores { "row,col": { text, style, colspan, rowspan } }
            };

            if (initialDataString && initialDataString.trim() !== "") {
                try {
                    const decodedData = atob(initialDataString); // Base64 decode
                    const parsedConfig = JSON.parse(decodedData);
                    
                    if (parsedConfig && typeof parsedConfig.rows === 'number' && typeof parsedConfig.cols === 'number' && typeof parsedConfig.cellData === 'object') {
                        tableConfig = parsedConfig;
                    } else {
                        console.warn("Invalid table data format in INITIAL_TABLE_DATA. Using default.");
                        showStatus("Nieprawid≈Çowy format danych tabeli. U≈ºywam domy≈õlnych.", "error");
                    }
                } catch (e) {
                    console.error("Failed to parse INITIAL_TABLE_DATA:", e);
                    showStatus("B≈ÇƒÖd ≈Çadowania danych tabeli. U≈ºywam domy≈õlnych.", "error");
                }
            } else {
                // Use sample data if INITIAL_TABLE_DATA is empty (first run or reset)
                const sampleData = [
                    ['Streamers', '3:0', '3:2', '3:2', '0:3', '', '', ''],
                    ['Player1', 'Team A', 'Team B', 'Map1', 'Score', '', '', ''],
                    ['test', '', '', '', '', '', '', ''],
                ];
                tableConfig.rows = Math.max(tableConfig.rows, sampleData.length);
                sampleData.forEach((rowContent, r) => {
                    rowContent.forEach((text, c) => {
                        if (text) {
                            tableConfig.cellData[`${r},${c}`] = { text };
                        }
                    });
                });
            }

            // Create column headers
            for (let j = 0; j < tableConfig.cols; j++) {
                const colLetter = String.fromCharCode(65 + j);
                const newHeader = document.createElement('th');
                newHeader.className = 'col-header';
                newHeader.textContent = colLetter;
                headerRow.appendChild(newHeader);
            }

            // Create rows and cells based on tableConfig
            const numRows = tableConfig.rows;
            const numCols = tableConfig.cols;
            const coveredCells = Array(numRows).fill(null).map(() => Array(numCols).fill(false));

            for (let i = 0; i < numRows; i++) {
                const row = document.createElement('tr');
                
                const rowHeader = document.createElement('td');
                rowHeader.className = 'row-header';
                rowHeader.textContent = i + 1;
                row.appendChild(rowHeader);
                
                for (let j = 0; j < numCols; j++) {
                    if (coveredCells[i][j]) {
                        continue; // This cell is covered by a previous cell's rowspan/colspan
                    }

                    const cell = document.createElement('td');
                    cell.className = 'cell';
                    cell.dataset.row = i;
                    cell.dataset.col = j;
                    
                    const cellKey = `${i},${j}`;
                    const data = tableConfig.cellData[cellKey];

                    if (data) {
                        cell.textContent = data.text || '';
                        if (data.style) {
                            Object.assign(cell.style, data.style);
                        }
                        
                        const rSpan = data.rowspan || 1;
                        const cSpan = data.colspan || 1;

                        if (rSpan > 1 || cSpan > 1) {
                            cell.setAttribute('rowspan', rSpan);
                            cell.setAttribute('colspan', cSpan);
                            cell.classList.add('merged'); // Add merged class for potential specific styling
                            for (let dr = 0; dr < rSpan; dr++) {
                                for (let dc = 0; dc < cSpan; dc++) {
                                    if (dr === 0 && dc === 0) continue;
                                    if (i + dr < numRows && j + dc < numCols) {
                                        coveredCells[i + dr][j + dc] = true;
                                    }
                                }
                            }
                        }
                    }
                    
                    cell.addEventListener('click', handleCellClick);
                    cell.addEventListener('dblclick', handleCellDblClick);
                    cell.addEventListener('mousedown', handleCellMouseDown);
                    cell.addEventListener('mouseover', handleCellMouseOver);
                    
                    row.appendChild(cell);
                }
                tbody.appendChild(row);
            }
        }

        function serializeTableDataToString() {
            const tbody = document.getElementById('spreadsheetBody');
            const headerRow = document.querySelector('#spreadsheet thead tr');
            
            const rows = tbody.children.length;
            const cols = headerRow.children.length - 1; // -1 for the row-header's empty th

            const cellData = {};

            for (let i = 0; i < rows; i++) {
                const rowElement = tbody.children[i];
                const cellElements = Array.from(rowElement.children).filter(c => c.classList.contains('cell'));

                for (const cell of cellElements) {
                    // Skip if cell is 'hidden' (though this class is not primarily used for merged rendering anymore)
                    // if (cell.classList.contains('hidden')) continue; 

                    const r = parseInt(cell.dataset.row);
                    const c = parseInt(cell.dataset.col);
                    const key = `${r},${c}`;
                    
                    const data = {};
                    if (cell.textContent) data.text = cell.textContent;

                    const styles = {};
                    if (cell.style.fontWeight && cell.style.fontWeight !== 'normal') styles.fontWeight = cell.style.fontWeight;
                    if (cell.style.fontStyle && cell.style.fontStyle !== 'normal') styles.fontStyle = cell.style.fontStyle;
                    if (cell.style.textDecoration && !cell.style.textDecoration.includes('none')) styles.textDecoration = cell.style.textDecoration; // 'none' can be complex
                    if (cell.style.textAlign && cell.style.textAlign !== 'start' && cell.style.textAlign !== 'left' && cell.style.textAlign !== '') styles.textAlign = cell.style.textAlign;
                    if (cell.style.fontSize && cell.style.fontSize !== '11px') styles.fontSize = cell.style.fontSize; // Default from .spreadsheet
                    if (cell.style.backgroundColor && cell.style.backgroundColor !== 'rgb(42, 42, 42)' && cell.style.backgroundColor !== '#2a2a2a') styles.backgroundColor = cell.style.backgroundColor; // Default from .cell
                    if (cell.style.color && cell.style.color !== 'rgb(255, 255, 255)' && cell.style.color !== 'white') styles.color = cell.style.color; // Default from body
                    
                    if (Object.keys(styles).length > 0) {
                        data.style = styles;
                    }

                    const colspan = cell.getAttribute('colspan');
                    const rowspan = cell.getAttribute('rowspan');

                    if (colspan && parseInt(colspan) > 1) data.colspan = parseInt(colspan);
                    if (rowspan && parseInt(rowspan) > 1) data.rowspan = parseInt(rowspan);
                    
                    if (data.text || data.style || data.colspan || data.rowspan) {
                         cellData[key] = data;
                    }
                }
            }
            
            const tableConfig = { rows, cols, cellData };
            const jsonString = JSON.stringify(tableConfig);
            return btoa(jsonString); // Encode to Base64
        }
        
        function updateSerializedDataOutput() {
            if (!isAdminMode) return;
            const serializedData = serializeTableDataToString();
            const outputTextarea = document.getElementById('tableDataOutput');
            if (outputTextarea) {
                outputTextarea.value = serializedData;
            }
        }

        function updateSerializedDataOutputAndShowInPanel() {
            if (!isAdminMode) {
                showStatus("Tylko administrator mo≈ºe wykonaƒá tƒô akcjƒô.", "error");
                return;
            }
            updateSerializedDataOutput();
            showAdminPanel(); // Ensure panel is visible
            const outputTextarea = document.getElementById('tableDataOutput');
            if (outputTextarea) outputTextarea.focus();
            showStatus('Dane tabeli gotowe do skopiowania w panelu administratora.', 'success');
        }


        function showAdminPanel() {
            document.getElementById('adminOverlay').style.display = 'block';
            document.getElementById('adminPanel').style.display = 'block';
            document.getElementById('passwordInput').focus();
        }
        
        function closeAdminPanel() {
            document.getElementById('adminOverlay').style.display = 'none';
            document.getElementById('adminPanel').style.display = 'none';
            document.getElementById('passwordInput').value = '';
            if (!isAdminMode) { // Hide copy section if not successfully logged in
                 document.getElementById('copySection').style.display = 'none';
            }
        }
        
        async function checkPassword() {
            const password = document.getElementById('passwordInput').value;
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
            
            if (hashHex === ADMIN_PASSWORD_HASH) {
                isAdminMode = true;
                document.getElementById('toolbar').classList.add('visible');
                document.getElementById('copySection').style.display = 'block';
                updateSerializedDataOutput(); // Populate textarea with current table data
                showStatus('Tryb administratora aktywowany!', 'success');
                // No need to close panel immediately, user might want to copy
            } else {
                isAdminMode = false; // Explicitly set on failure
                document.getElementById('toolbar').classList.remove('visible');
                showStatus('Nieprawid≈Çowe has≈Ço!', 'error');
                document.getElementById('passwordInput').value = ''; // Clear password field
                document.getElementById('copySection').style.display = 'none';
            }
        }
        
        function copyToClipboard() {
            const textarea = document.getElementById('tableDataOutput');
            textarea.select();
            // textarea.setSelectionRange(0, textarea.value.length); // For broader compatibility

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(textarea.value).then(() => {
                    showStatus('Dane tabeli skopiowane do schowka!', 'success');
                }).catch(err => {
                    console.error('Async clipboard copy failed:', err);
                    // Fallback to execCommand
                    try {
                        document.execCommand('copy');
                        showStatus('Dane tabeli skopiowane (fallback)!', 'success');
                    } catch (e) {
                        showStatus('B≈ÇƒÖd podczas kopiowania: ' + e.message, 'error');
                    }
                });
            } else { // Fallback for older browsers
                try {
                    document.execCommand('copy');
                    showStatus('Dane tabeli skopiowane (fallback)!', 'success');
                } catch (err) {
                    showStatus('B≈ÇƒÖd podczas kopiowania', 'error');
                }
            }
        }
        
        // Event handling for cells (click, dblclick, mousedown, mouseover)
        // These functions are attached directly to cells in initSpreadsheet
        function handleCellClick(e) {
            const targetCell = e.target.closest('.cell');
            if (!targetCell) return;

            if (selectedCell) {
                selectedCell.classList.remove('selected');
            }
            selectedCell = targetCell;
            selectedCell.classList.add('selected');
            
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [selectedCell];

            // Update color pickers and font size to reflect selected cell's style
            if (isAdminMode) {
                document.getElementById('fontSizeInput').value = parseInt(selectedCell.style.fontSize) || 11;
                document.getElementById('bgColorPicker').value = rgbToHex(selectedCell.style.backgroundColor) || '#2a2a2a';
                document.getElementById('textColorPicker').value = rgbToHex(selectedCell.style.color) || '#ffffff';
            }
        }
        
        function handleCellDblClick(e) {
            if (!isAdminMode) return;
            const cell = e.target.closest('.cell');
            if (!cell || cell.classList.contains('editing')) return;
            
            const currentText = cell.textContent;
            cell.classList.add('editing');
            cell.innerHTML = `<input type="text" class="cell-input" value="${currentText}">`;
            
            const input = cell.querySelector('.cell-input');
            input.focus();
            input.select();
            
            input.addEventListener('blur', () => finishEdit(cell, input, currentText), { once: true });
            input.addEventListener('keydown', (ev) => {
                if (ev.key === 'Enter') {
                    input.blur(); // This will trigger the blur event listener
                } else if (ev.key === 'Escape') {
                    cell.textContent = currentText; // Restore original text
                    cell.classList.remove('editing');
                    cell.innerHTML = currentText; // Remove input
                }
            });
        }
        
        function finishEdit(cell, input, originalText) {
            // Check if cell still exists and is in editing mode (it might have been removed by blur+escape)
            if (!cell || !cell.classList.contains('editing')) return;

            cell.textContent = input.value;
            cell.classList.remove('editing');
            if (isAdminMode) {
                updateSerializedDataOutput();
            }
        }
        
        function handleCellMouseDown(e) {
            const targetCell = e.target.closest('.cell');
            if (!isAdminMode || !targetCell) return;
            
            // If clicking on an already selected cell, don't restart selection unless Shift/Ctrl is held (not implemented here)
            // For simplicity, always restart selection process on mousedown on a cell.
            isSelecting = true;
            startCellForSelection = targetCell;
            
            // Clear previous multi-selection, select only the clicked cell initially
            selectedCells.forEach(sc => sc.classList.remove('selected'));
            selectedCell = targetCell; // Keep track of the primary selected cell
            selectedCell.classList.add('selected');
            selectedCells = [selectedCell];

            document.getElementById('rangeSelector').style.display = 'none'; // Hide old selector
        }
        
        function handleCellMouseOver(e) {
            if (!isSelecting || !isAdminMode) return;
            const currentCell = e.target.closest('.cell');
            if (!currentCell || !startCellForSelection) return;

            const startRow = parseInt(startCellForSelection.dataset.row);
            const startCol = parseInt(startCellForSelection.dataset.col);
            const endRow = parseInt(currentCell.dataset.row);
            const endCol = parseInt(currentCell.dataset.col);
            
            selectedCells.forEach(cell => cell.classList.remove('selected'));
            selectedCells = [];
            
            const minRow = Math.min(startRow, endRow);
            const maxRow = Math.max(startRow, endRow);
            const minCol = Math.min(startCol, endCol);
            const maxCol = Math.max(startCol, endCol);
            
            const rangeSelector = document.getElementById('rangeSelector');
            const firstCellRect = document.querySelector(`[data-row="${minRow}"][data-col="${minCol}"]`).getBoundingClientRect();
            const lastCellRect = document.querySelector(`[data-row="${maxRow}"][data-col="${maxCol}"]`).getBoundingClientRect();
            const spreadsheetRect = document.getElementById('spreadsheet').getBoundingClientRect();

            rangeSelector.style.left = (firstCellRect.left - spreadsheetRect.left) + 'px';
            rangeSelector.style.top = (firstCellRect.top - spreadsheetRect.top) + 'px';
            rangeSelector.style.width = (lastCellRect.right - firstCellRect.left) + 'px';
            rangeSelector.style.height = (lastCellRect.bottom - firstCellRect.top) + 'px';
            rangeSelector.style.display = 'block';

            for (let r = minRow; r <= maxRow; r++) {
                for (let c = minCol; c <= maxCol; c++) {
                    const cell = document.querySelector(`td.cell[data-row="${r}"][data-col="${c}"]`);
                    // Select only if the cell is not part of a merge (i.e., it's a "main" cell)
                    // or if it's not hidden. This logic might need refinement for complex merges.
                    // For now, select all cells in the geometric range.
                    if (cell) { 
                        cell.classList.add('selected');
                        selectedCells.push(cell);
                    }
                }
            }
        }
        
        document.addEventListener('mouseup', () => {
            if (isSelecting) {
                isSelecting = false;
                document.getElementById('rangeSelector').style.display = 'none';
                // selectedCells array is now populated with the final selection
                if (selectedCells.length > 0) {
                     selectedCell = selectedCells[0]; // Primary selected is the first one
                }
            }
        });
        
        // Formatting functions
        function applyStyleToSelectedCells(styleProperty, value, toggleValue = null) {
            if (!isAdminMode || selectedCells.length === 0) return;
            selectedCells.forEach(cell => {
                if (toggleValue && cell.style[styleProperty] === value) {
                    cell.style[styleProperty] = toggleValue;
                } else {
                    cell.style[styleProperty] = value;
                }
            });
            if (isAdminMode) updateSerializedDataOutput();
        }

        function formatBold() { applyStyleToSelectedCells('fontWeight', 'bold', 'normal'); }
        function formatItalic() { applyStyleToSelectedCells('fontStyle', 'italic', 'normal'); }
        function formatUnderline() { applyStyleToSelectedCells('textDecoration', 'underline', 'none'); }
        function alignLeft() { applyStyleToSelectedCells('textAlign', 'left'); }
        function alignCenter() { applyStyleToSelectedCells('textAlign', 'center'); }
        function alignRight() { applyStyleToSelectedCells('textAlign', 'right'); }
        
        function changeFontSize() {
            if (!isAdminMode || selectedCells.length === 0) return;
            const fontSize = document.getElementById('fontSizeInput').value;
            applyStyleToSelectedCells('fontSize', fontSize + 'px');
        }
        
        function changeBgColor() {
            if (!isAdminMode || selectedCells.length === 0) return;
            const color = document.getElementById('bgColorPicker').value;
            applyStyleToSelectedCells('backgroundColor', color);
        }
        
        function changeTextColor() {
            if (!isAdminMode || selectedCells.length === 0) return;
            const color = document.getElementById('textColorPicker').value;
            applyStyleToSelectedCells('color', color);
        }
        
        function mergeCells() {
            if (!isAdminMode || selectedCells.length < 2) {
                showStatus('Zaznacz co najmniej 2 kom√≥rki (prostokƒÖtny obszar) do po≈ÇƒÖczenia!', 'error');
                return;
            }
            
            const rows = selectedCells.map(cell => parseInt(cell.dataset.row));
            const cols = selectedCells.map(cell => parseInt(cell.dataset.col));
            const minRow = Math.min(...rows);
            const minCol = Math.min(...cols);
            const maxRow = Math.max(...rows);
            const maxCol = Math.max(...cols);
            
            // Check if selection forms a rectangle
            let isRectangle = true;
            const selectedCoords = new Set(selectedCells.map(c => `${c.dataset.row},${c.dataset.col}`));
            if (selectedCells.length !== (maxRow - minRow + 1) * (maxCol - minCol + 1)) {
                isRectangle = false;
            } else {
                for (let r = minRow; r <= maxRow; r++) {
                    for (let c = minCol; c <= maxCol; c++) {
                        if (!selectedCoords.has(`${r},${c}`)) {
                            isRectangle = false; break;
                        }
                    }
                    if (!isRectangle) break;
                }
            }

            if (!isRectangle) {
                showStatus('Zaznaczenie do scalenia musi byƒá prostokƒÖtne i ciƒÖg≈Çe!', 'error');
                return;
            }

            const mainCell = document.querySelector(`td.cell[data-row="${minRow}"][data-col="${minCol}"]`);
            if (!mainCell) {
                 showStatus('Nie znaleziono g≈Ç√≥wnej kom√≥rki do scalenia.', 'error');
                 return;
            }
            
            const rowSpan = maxRow - minRow + 1;
            const colSpan = maxCol - minCol + 1;
            
            // Collect text from all cells being merged, main cell's text first
            let mergedText = mainCell.textContent.trim();
            selectedCells.forEach(cell => {
                if (cell !== mainCell && cell.textContent.trim()) {
                    mergedText += (mergedText ? " " : "") + cell.textContent.trim();
                }
            });

            mainCell.setAttribute('colspan', colSpan);
            mainCell.setAttribute('rowspan', rowSpan);
            mainCell.textContent = mergedText; // Set combined text
            
            // This will effectively "hide" other cells as they won't be rendered by initSpreadsheet
            // The actual DOM elements for other cells in the merged area will be removed by initSpreadsheet
            // when it re-renders based on the new data with colspan/rowspan.
            const currentData = serializeTableDataToString();
            initSpreadsheet(currentData); // Re-initialize to correctly render merged cells
            showStatus('Kom√≥rki po≈ÇƒÖczone.', 'success');
            if (isAdminMode) updateSerializedDataOutput(); // Update data string after re-initialization
        }
        
        function unmergeCells() {
            if (!isAdminMode || selectedCells.length === 0) {
                 showStatus('Zaznacz kom√≥rkƒô do roz≈ÇƒÖczenia.', 'error');
                return;
            }
            
            let refreshNeeded = false;
            selectedCells.forEach(cell => {
                if (cell.hasAttribute('colspan') || cell.hasAttribute('rowspan')) {
                    cell.removeAttribute('colspan');
                    cell.removeAttribute('rowspan');
                    cell.classList.remove('merged');
                    refreshNeeded = true;
                }
            });
            
            if (refreshNeeded) {
                const currentData = serializeTableDataToString();
                initSpreadsheet(currentData); // Re-initialize to render unmerged cells correctly
                showStatus('Kom√≥rki roz≈ÇƒÖczone. Tabela od≈õwie≈ºona.', 'success');
                if (isAdminMode) updateSerializedDataOutput();
            } else {
                showStatus('Zaznaczona kom√≥rka nie jest scalona.', 'info');
            }
        }
        
        // Add/Delete Rows/Columns
        function addRow() {
            if (!isAdminMode) return;
            const tbody = document.getElementById('spreadsheetBody');
            const numRows = tbody.children.length;
            const numCols = document.querySelector('#spreadsheet thead tr').children.length - 1;

            const newRow = document.createElement('tr');
            const rowHeader = document.createElement('td');
            rowHeader.className = 'row-header';
            rowHeader.textContent = numRows + 1;
            newRow.appendChild(rowHeader);

            for (let j = 0; j < numCols; j++) {
                const cell = document.createElement('td');
                cell.className = 'cell';
                cell.dataset.row = numRows;
                cell.dataset.col = j;
                cell.addEventListener('click', handleCellClick);
                cell.addEventListener('dblclick', handleCellDblClick);
                cell.addEventListener('mousedown', handleCellMouseDown);
                cell.addEventListener('mouseover', handleCellMouseOver);
                newRow.appendChild(cell);
            }
            tbody.appendChild(newRow);
            if (isAdminMode) updateSerializedDataOutput();
        }

        function addColumn() {
            if (!isAdminMode) return;
            const headerRow = document.querySelector('#spreadsheet thead tr');
            const numCols = headerRow.children.length - 1;
            
            const newColHeader = document.createElement('th');
            newColHeader.className = 'col-header';
            newColHeader.textContent = String.fromCharCode(65 + numCols);
            headerRow.appendChild(newColHeader);

            const tbody = document.getElementById('spreadsheetBody');
            Array.from(tbody.children).forEach((row, rowIndex) => {
                const cell = document.createElement('td');
                cell.className = 'cell';
                cell.dataset.row = rowIndex;
                cell.dataset.col = numCols;
                cell.addEventListener('click', handleCellClick);
                cell.addEventListener('dblclick', handleCellDblClick);
                cell.addEventListener('mousedown', handleCellMouseDown);
                cell.addEventListener('mouseover', handleCellMouseOver);
                row.appendChild(cell);
            });
            if (isAdminMode) updateSerializedDataOutput();
        }

        function deleteRow() {
            if (!isAdminMode || !selectedCell) {
                showStatus('Zaznacz kom√≥rkƒô w wierszu do usuniƒôcia.', 'error');
                return;
            }
            const rowElement = selectedCell.closest('tr');
            if (rowElement && document.getElementById('spreadsheetBody').children.length > 1) { // Keep at least one row
                rowElement.remove();
                // Re-index rows
                Array.from(document.getElementById('spreadsheetBody').children).forEach((row, index) => {
                    row.querySelector('.row-header').textContent = index + 1;
                    Array.from(row.querySelectorAll('.cell')).forEach(cell => cell.dataset.row = index);
                });
                selectedCell = null; selectedCells = [];
                if (isAdminMode) updateSerializedDataOutput();
            } else if (document.getElementById('spreadsheetBody').children.length <= 1) {
                showStatus('Nie mo≈ºna usunƒÖƒá ostatniego wiersza.', 'error');
            }
        }

        function deleteColumn() {
            if (!isAdminMode || !selectedCell) {
                 showStatus('Zaznacz kom√≥rkƒô w kolumnie do usuniƒôcia.', 'error');
                return;
            }
            const colIndex = parseInt(selectedCell.dataset.col);
            const headerRow = document.querySelector('#spreadsheet thead tr');
            
            if (headerRow.children.length -1 <= 1) { // Keep at least one column
                 showStatus('Nie mo≈ºna usunƒÖƒá ostatniej kolumny.', 'error');
                return;
            }

            if (headerRow.children[colIndex + 1]) {
                headerRow.children[colIndex + 1].remove();
            }

            Array.from(document.getElementById('spreadsheetBody').children).forEach(row => {
                if (row.children[colIndex + 1]) {
                    row.children[colIndex + 1].remove();
                }
            });

            // Re-index column headers and cell data-col attributes
            Array.from(headerRow.children).forEach((th, index) => {
                if (index > 0) th.textContent = String.fromCharCode(65 + index - 1);
            });
            Array.from(document.querySelectorAll('#spreadsheetBody .cell')).forEach(cell => {
                const currentCol = parseInt(cell.dataset.col);
                if (currentCol > colIndex) {
                    cell.dataset.col = currentCol - 1;
                }
            });
            selectedCell = null; selectedCells = [];
            if (isAdminMode) updateSerializedDataOutput();
        }
        
        // Keyboard interactions
        document.addEventListener('keydown', (e) => {
            if (!isAdminMode) return;
            
            if (e.key === 'Delete' && selectedCells.length > 0 && document.activeElement.tagName !== 'INPUT') {
                e.preventDefault();
                selectedCells.forEach(cell => {
                    if(!cell.classList.contains('editing')) cell.textContent = '';
                });
                if (isAdminMode) updateSerializedDataOutput();
            }
            
            // Basic Ctrl+C, Ctrl+V (text only) could be added here if needed,
            // but the primary copy mechanism is for the whole table data.
        });

        // Helper to convert rgb() to hex for color pickers
        function rgbToHex(rgb) {
            if (!rgb || !rgb.startsWith('rgb')) return rgb; // Return if not rgb or already hex/named
            const result = /^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/.exec(rgb);
            if (!result) return rgb;
            const r = parseInt(result[1]).toString(16).padStart(2, '0');
            const g = parseInt(result[2]).toString(16).padStart(2, '0');
            const b = parseInt(result[3]).toString(16).padStart(2, '0');
            return `#${r}${g}${b}`;
        }
        
        // Initialization
        document.addEventListener('DOMContentLoaded', () => {
            initSpreadsheet();
            // Attach event listeners for font size and color pickers to update on any change, not just button click
            document.getElementById('fontSizeInput').addEventListener('change', changeFontSize);
            document.getElementById('bgColorPicker').addEventListener('input', changeBgColor); // 'input' for live preview
            document.getElementById('textColorPicker').addEventListener('input', changeTextColor); // 'input' for live preview
        });
    </script>
</body>
</html>
